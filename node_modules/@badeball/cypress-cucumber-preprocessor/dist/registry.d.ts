import { Expression, ParameterTypeRegistry } from "@cucumber/cucumber-expressions";
import parse from "@cucumber/tag-expressions";
import { IdGenerator } from "@cucumber/messages";
import DataTable from "./data_table";
import { CypressCucumberError } from "./helpers/error";
import { IHookBody, IStepHookBody, IStepHookParameter, IParameterTypeDefinition, IStepDefinitionBody, IHookParameter } from "./public-member-types";
import { Position } from "./helpers/source-map";
export interface IStepDefinition<T extends unknown[], C extends Mocha.Context> {
    id: string;
    expression: Expression;
    implementation: IStepDefinitionBody<T, C>;
    position?: Position;
}
export declare class MissingDefinitionError extends CypressCucumberError {
}
export declare class MultipleDefinitionsError extends CypressCucumberError {
}
export type ScenarioHookKeyword = "Before" | "After";
export type StepHookKeyword = "BeforeStep" | "AfterStep";
interface IBaseHook<Implementation, Keyword> {
    tags?: string;
    name?: string;
    node: ReturnType<typeof parse>;
    implementation: Implementation;
    keyword: Keyword;
    position?: Position;
}
export interface IHook extends IBaseHook<IHookBody, ScenarioHookKeyword> {
    id: string;
}
export type IStepHook = IBaseHook<IStepHookBody, StepHookKeyword>;
export declare class Registry {
    private experimentalSourceMap;
    parameterTypeRegistry: ParameterTypeRegistry;
    private preliminaryStepDefinitions;
    stepDefinitions: IStepDefinition<unknown[], Mocha.Context>[];
    private preliminaryHooks;
    hooks: IHook[];
    stepHooks: IStepHook[];
    constructor(experimentalSourceMap: boolean);
    finalize(newId: IdGenerator.NewId): void;
    defineStep(description: string | RegExp, implementation: () => void): void;
    defineParameterType<T, C extends Mocha.Context>({ name, regexp, transformer, }: IParameterTypeDefinition<T, C>): void;
    defineHook(keyword: ScenarioHookKeyword, options: {
        tags?: string;
    }, fn: IHookBody): void;
    defineBefore(options: {
        tags?: string;
    }, fn: IHookBody): void;
    defineAfter(options: {
        tags?: string;
    }, fn: IHookBody): void;
    defineStepHook(keyword: StepHookKeyword, options: {
        tags?: string;
    }, fn: IStepHookBody): void;
    defineBeforeStep(options: {
        tags?: string;
    }, fn: IStepHookBody): void;
    defineAfterStep(options: {
        tags?: string;
    }, fn: IStepHookBody): void;
    getMatchingStepDefinitions(text: string): IStepDefinition<unknown[], Mocha.Context>[];
    resolveStepDefintion(text: string): IStepDefinition<unknown[], Mocha.Context>;
    runStepDefininition(world: Mocha.Context, text: string, argument?: DataTable | string): unknown;
    resolveHooks(keyword: ScenarioHookKeyword, tags: string[]): IHook[];
    resolveBeforeHooks(tags: string[]): IHook[];
    resolveAfterHooks(tags: string[]): IHook[];
    runHook(world: Mocha.Context, hook: IHook, options: IHookParameter): void;
    resolveStepHooks(keyword: StepHookKeyword, tags: string[]): IStepHook[];
    resolveBeforeStepHooks(tags: string[]): IStepHook[];
    resolveAfterStepHooks(tags: string[]): IStepHook[];
    runStepHook(world: Mocha.Context, hook: IStepHook, options: IStepHookParameter): void;
}
export declare function withRegistry(experimentalSourceMap: boolean, fn: () => void): Registry;
export declare function assignRegistry(registry: Registry): void;
export declare function freeRegistry(): void;
export declare function getRegistry(): Registry;
export {};
