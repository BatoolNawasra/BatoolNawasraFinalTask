"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.afterScreenshotHandler = exports.afterSpecHandler = exports.beforeSpecHandler = exports.afterRunHandler = exports.beforeRunHandler = exports.addCucumberPreprocessorPlugin = exports.resolvePreprocessorConfiguration = exports.AfterStep = exports.BeforeStep = exports.After = exports.Before = exports.defineParameterType = exports.Step = exports.defineStep = exports.Then = exports.When = exports.Given = exports.doesFeatureMatch = exports.isFeature = exports.DataTable = exports.attach = void 0;
const messages_1 = require("@cucumber/messages");
const tag_expressions_1 = __importDefault(require("@cucumber/tag-expressions"));
const base64_js_1 = require("base64-js");
const error_1 = require("./helpers/error");
const ast_1 = require("./helpers/ast");
const constants_1 = require("./constants");
const cypress_task_definitions_1 = require("./cypress-task-definitions");
const browser_runtime_1 = require("./browser-runtime");
const cypress_1 = require("./helpers/cypress");
const data_table_1 = __importDefault(require("./data_table"));
exports.DataTable = data_table_1.default;
const registry_1 = require("./registry");
function defineStep(description, implementation) {
    (0, registry_1.getRegistry)().defineStep(description, implementation);
}
exports.Given = defineStep;
exports.When = defineStep;
exports.Then = defineStep;
exports.defineStep = defineStep;
function runStepDefininition(world, text, argument) {
    cy.then(() => {
        (0, cypress_1.runStepWithLogGroup)({
            keyword: "Step",
            text,
            fn: () => (0, registry_1.getRegistry)().runStepDefininition(world, text, argument),
        });
    });
}
exports.Step = runStepDefininition;
function defineParameterType(options) {
    (0, registry_1.getRegistry)().defineParameterType(options);
}
exports.defineParameterType = defineParameterType;
function defineBefore(optionsOrFn, maybeFn) {
    if (typeof optionsOrFn === "function") {
        (0, registry_1.getRegistry)().defineBefore({}, optionsOrFn);
    }
    else if (typeof optionsOrFn === "object" && typeof maybeFn === "function") {
        (0, registry_1.getRegistry)().defineBefore(optionsOrFn, maybeFn);
    }
    else {
        throw new Error("Unexpected argument for Before hook");
    }
}
exports.Before = defineBefore;
function defineAfter(optionsOrFn, maybeFn) {
    if (typeof optionsOrFn === "function") {
        (0, registry_1.getRegistry)().defineAfter({}, optionsOrFn);
    }
    else if (typeof optionsOrFn === "object" && typeof maybeFn === "function") {
        (0, registry_1.getRegistry)().defineAfter(optionsOrFn, maybeFn);
    }
    else {
        throw new Error("Unexpected argument for After hook");
    }
}
exports.After = defineAfter;
function defineBeforeStep(optionsOrFn, maybeFn) {
    if (typeof optionsOrFn === "function") {
        (0, registry_1.getRegistry)().defineBeforeStep({}, optionsOrFn);
    }
    else if (typeof optionsOrFn === "object" && typeof maybeFn === "function") {
        (0, registry_1.getRegistry)().defineBeforeStep(optionsOrFn, maybeFn);
    }
    else {
        throw new Error("Unexpected argument for BeforeStep hook");
    }
}
exports.BeforeStep = defineBeforeStep;
function defineAfterStep(optionsOrFn, maybeFn) {
    if (typeof optionsOrFn === "function") {
        (0, registry_1.getRegistry)().defineAfterStep({}, optionsOrFn);
    }
    else if (typeof optionsOrFn === "object" && typeof maybeFn === "function") {
        (0, registry_1.getRegistry)().defineAfterStep(optionsOrFn, maybeFn);
    }
    else {
        throw new Error("Unexpected argument for AfterStep hook");
    }
}
exports.AfterStep = defineAfterStep;
function createStringAttachment(data, mediaType, encoding) {
    const taskData = {
        data,
        mediaType,
        encoding,
    };
    cy.task(cypress_task_definitions_1.TASK_CREATE_STRING_ATTACHMENT, taskData, {
        log: false,
    });
}
function attach(data, mediaType) {
    if (typeof data === "string") {
        mediaType = mediaType !== null && mediaType !== void 0 ? mediaType : "text/plain";
        if (mediaType.startsWith("base64:")) {
            createStringAttachment(data, mediaType.replace("base64:", ""), messages_1.AttachmentContentEncoding.BASE64);
        }
        else {
            createStringAttachment(data, mediaType !== null && mediaType !== void 0 ? mediaType : "text/plain", messages_1.AttachmentContentEncoding.IDENTITY);
        }
    }
    else if (data instanceof ArrayBuffer) {
        if (typeof mediaType !== "string") {
            throw Error("ArrayBuffer attachments must specify a media type");
        }
        createStringAttachment((0, base64_js_1.fromByteArray)(new Uint8Array(data)), mediaType, messages_1.AttachmentContentEncoding.BASE64);
    }
    else {
        throw Error("Invalid attachment data: must be a ArrayBuffer or string");
    }
}
exports.attach = attach;
function isFeature() {
    return Cypress.env(constants_1.INTERNAL_SPEC_PROPERTIES) != null;
}
exports.isFeature = isFeature;
const NOT_FEATURE_ERROR = "Expected to find internal properties, but didn't. This is likely because you're calling doesFeatureMatch() in a non-feature spec. Use doesFeatureMatch() in combination with isFeature() if you have both feature and non-feature specs";
function doesFeatureMatch(expression) {
    let pickle;
    try {
        pickle = (0, browser_runtime_1.retrieveInternalSpecProperties)().pickle;
    }
    catch (_a) {
        throw (0, error_1.createError)(NOT_FEATURE_ERROR);
    }
    return (0, tag_expressions_1.default)(expression).evaluate((0, ast_1.collectTagNames)(pickle.tags));
}
exports.doesFeatureMatch = doesFeatureMatch;
/**
 * Everything below exist merely for the purpose of being nice with TypeScript. All of these methods
 * are exclusively used in the node environment and the node field in package.json points to
 * ./lib/entrypoint-node.ts.
 */
function createUnimplemented() {
    return new Error("Plugin methods aren't available in a browser environment");
}
function resolvePreprocessorConfiguration(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
cypressConfig, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
environment, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
implicitIntegrationFolder, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
configurationFileResolver) {
    throw createUnimplemented();
}
exports.resolvePreprocessorConfiguration = resolvePreprocessorConfiguration;
async function addCucumberPreprocessorPlugin(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
on, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
config, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
options = {}) {
    throw createUnimplemented();
}
exports.addCucumberPreprocessorPlugin = addCucumberPreprocessorPlugin;
async function beforeRunHandler(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
config) {
    throw createUnimplemented();
}
exports.beforeRunHandler = beforeRunHandler;
async function afterRunHandler(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
config) {
    throw createUnimplemented();
}
exports.afterRunHandler = afterRunHandler;
async function beforeSpecHandler(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
config, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
spec) {
    throw createUnimplemented();
}
exports.beforeSpecHandler = beforeSpecHandler;
async function afterSpecHandler(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
config, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
spec, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
results) {
    throw createUnimplemented();
}
exports.afterSpecHandler = afterSpecHandler;
async function afterScreenshotHandler(
// eslint-disable-next-line @typescript-eslint/no-unused-vars
config, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
details) {
    throw createUnimplemented();
}
exports.afterScreenshotHandler = afterScreenshotHandler;
