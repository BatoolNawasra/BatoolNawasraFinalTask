"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePost10Configuration = void 0;
const parser_1 = require("@babel/parser");
function parseEnv(object) {
    return object.properties.reduce((env, property) => {
        if (property.type === "ObjectProperty" &&
            property.key.type === "Identifier" &&
            property.value.type == "StringLiteral") {
            env[property.key.name] = property.value.value;
        }
        return env;
    }, {});
}
function parseTestingTypeObject(object) {
    const test = {};
    for (const property of object.properties) {
        if (property.type === "ObjectProperty" &&
            property.key.type === "Identifier") {
            if (property.key.name === "specPattern" ||
                property.key.name === "excludeSpecPattern") {
                const propertyName = property.key.name;
                if (property.value.type === "StringLiteral") {
                    test[propertyName] = property.value.value;
                }
                else if (property.value.type === "ArrayExpression") {
                    test[propertyName] = property.value.elements.map((element) => {
                        var _a;
                        if (element && element.type === "StringLiteral") {
                            return element.value;
                        }
                        else {
                            throw new Error(`Expected a string literal for ${propertyName}.[], but got ${(_a = element === null || element === void 0 ? void 0 : element.type) !== null && _a !== void 0 ? _a : "null"}`);
                        }
                    });
                }
                else {
                    throw new Error(`Expected a string literal for ${propertyName}, but got ${property.value.type}`);
                }
            }
            else if (property.key.name === "reporter") {
                const propertyName = property.key.name;
                if (property.value.type === "StringLiteral") {
                    test[propertyName] = property.value.value;
                }
                else {
                    throw new Error(`Expected a string literal for ${propertyName}, but got ${property.value.type}`);
                }
            }
            else if (property.key.name === "env") {
                if (property.value.type === "ObjectExpression") {
                    test.env = parseEnv(property.value);
                }
                else {
                    throw new Error("Expected a ObjectExpression for e2e, but got " +
                        property.value.type);
                }
            }
        }
    }
    return test;
}
function parseTestingTypesObject(object) {
    const types = {};
    for (const property of object.properties) {
        if (property.type === "ObjectProperty" &&
            property.key.type === "Identifier" &&
            property.value.type === "ObjectExpression") {
            if (property.key.name === "e2e") {
                types.e2e = parseTestingTypeObject(property.value);
            }
            else if (property.key.name === "component") {
                types.component = parseTestingTypeObject(property.value);
            }
        }
    }
    return types;
}
function parsePost10Configuration(source) {
    const ast = (0, parser_1.parse)(source, {
        sourceType: "unambiguous",
        plugins: ["typescript"],
    });
    // module.exports = { e2e: { specPattern: "foo/bar" } };
    if (ast.program.sourceType === "script") {
        for (const statement of ast.program.body) {
            if (statement.type === "ExpressionStatement") {
                const { expression } = statement;
                if (expression.type === "AssignmentExpression" &&
                    expression.operator === "=") {
                    const { left } = expression;
                    if (left.type === "MemberExpression" &&
                        left.object.type == "Identifier" &&
                        left.object.name === "module" &&
                        left.property.type === "Identifier" &&
                        left.property.name === "exports") {
                        const { right } = expression;
                        if (right.type === "ObjectExpression") {
                            const result = parseTestingTypesObject(right);
                            if (result) {
                                return result;
                            }
                        }
                    }
                }
            }
        }
    }
    // module.exports = defineConfig({ e2e: { specPattern: "foo/bar" } });
    if (ast.program.sourceType === "script") {
        for (const statement of ast.program.body) {
            if (statement.type === "ExpressionStatement") {
                const { expression } = statement;
                if (expression.type === "AssignmentExpression" &&
                    expression.operator === "=") {
                    const { left } = expression;
                    if (left.type === "MemberExpression" &&
                        left.object.type == "Identifier" &&
                        left.object.name === "module" &&
                        left.property.type === "Identifier" &&
                        left.property.name === "exports") {
                        const { right } = expression;
                        if (right.type === "CallExpression") {
                            const { callee, arguments: [argument], } = right;
                            if (callee.type === "Identifier" &&
                                callee.name === "defineConfig") {
                                if (argument && argument.type === "ObjectExpression") {
                                    const result = parseTestingTypesObject(argument);
                                    if (result) {
                                        return result;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // export default { e2e: { specPattern: "foo/bar" } };
    if (ast.program.sourceType === "module") {
        for (const statement of ast.program.body) {
            if (statement.type === "ExportDefaultDeclaration" &&
                statement.exportKind === "value") {
                const { declaration } = statement;
                if (declaration.type === "ObjectExpression") {
                    const result = parseTestingTypesObject(declaration);
                    if (result) {
                        return result;
                    }
                }
            }
        }
    }
    // export default defineConfig({ e2e: { specPattern: "foo/bar" } });
    if (ast.program.sourceType === "module") {
        for (const statement of ast.program.body) {
            if (statement.type === "ExportDefaultDeclaration" &&
                statement.exportKind === "value") {
                const { declaration } = statement;
                if (declaration.type === "CallExpression") {
                    const { callee, arguments: [argument], } = declaration;
                    if (callee.type === "Identifier" && callee.name === "defineConfig") {
                        if (argument && argument.type === "ObjectExpression") {
                            const result = parseTestingTypesObject(argument);
                            if (result) {
                                return result;
                            }
                        }
                    }
                }
            }
        }
    }
    return {};
}
exports.parsePost10Configuration = parsePost10Configuration;
